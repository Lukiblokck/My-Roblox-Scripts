-- Super Secure Anti-Exploit System
-- Place in ServerScriptService

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Configuration
local SECURITY_SETTINGS = {
    MaxWalkSpeed = 24, -- Maximum allowed walkspeed
    MaxJumpPower = 100, -- Maximum allowed jump power
    PositionCheckInterval = 2, -- Seconds between position checks
    MaxPositionDelta = 50, -- Maximum allowed movement between checks (studs)
    NoClipCheckInterval = 1, -- Seconds between noclip checks
    RemoteRateLimit = 10, -- Max remote events per second
    MaxMemoryUsage = 500, -- Max memory in MB before flagging
    AutoKick = true, -- Automatically kick detected exploiters
    LogToConsole = true -- Log detections to output
}

-- Security System
local SecuritySystem = {
    PlayerData = {},
    Detections = {}
}

-- Initialize player tracking
function SecuritySystem:TrackPlayer(player)
    local data = {
        LastPosition = nil,
        LastRemoteTime = {},
        RemoteCount = 0,
        Character = nil,
        Connections = {}
    }
    self.PlayerData[player] = data
    
    -- Character added event
    data.Connections.characterAdded = player.CharacterAdded:Connect(function(character)
        self:SetupCharacter(player, character)
    end)
    
    -- Remote event monitoring
    data.Connections.remoteSpam = player:GetPropertyChangedSignal("Character"):Connect(function()
        self:CheckRemoteSpam(player)
    end)
end

-- Set up character monitoring
function SecuritySystem:SetupCharacter(player, character)
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    local data = self.PlayerData[player]
    data.Character = character
    data.LastPosition = rootPart.Position
    
    -- Speed hack detection
    data.Connections.walkSpeed = humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if humanoid.WalkSpeed > SECURITY_SETTINGS.MaxWalkSpeed then
            humanoid.WalkSpeed = 16
            self:Flag(player, "SpeedHack", "WalkSpeed: "..humanoid.WalkSpeed)
        end
    end)
    
    -- Jump power detection
    data.Connections.jumpPower = humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
        if humanoid.JumpPower > SECURITY_SETTINGS.MaxJumpPower then
            humanoid.JumpPower = 50
            self:Flag(player, "JumpHack", "JumpPower: "..humanoid.JumpPower)
        end
    end)
    
    -- Size hack detection
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            data.Connections["size_"..part.Name] = part:GetPropertyChangedSignal("Size"):Connect(function()
                if part.Size.Magnitude > 10 then
                    part.Size = Vector3.new(2, 2, 2)
                    self:Flag(player, "SizeHack", "Part: "..part.Name.." Size: "..tostring(part.Size))
                end
            end)
        end
    end
    
    -- Position monitoring coroutine
    data.Connections.positionCheck = coroutine.create(function()
        while character and character.Parent do
            self:CheckPosition(player, rootPart)
            wait(SECURITY_SETTINGS.PositionCheckInterval)
        end
    end)
    coroutine.resume(data.Connections.positionCheck)
    
    -- NoClip detection coroutine
    data.Connections.noClipCheck = coroutine.create(function()
        while character and character.Parent do
            self:CheckNoClip(player, character, humanoid, rootPart)
            wait(SECURITY_SETTINGS.NoClipCheckInterval)
        end
    end)
    coroutine.resume(data.Connections.noClipCheck)
end

-- Position validation
function SecuritySystem:CheckPosition(player, rootPart)
    local data = self.PlayerData[player]
    if not data.LastPosition then return end
    
    local distance = (rootPart.Position - data.LastPosition).Magnitude
    if distance > SECURITY_SETTINGS.MaxPositionDelta then
        rootPart.CFrame = CFrame.new(data.LastPosition)
        self:Flag(player, "TeleportHack", "Distance: "..distance)
    end
    
    data.LastPosition = rootPart.Position
end

-- NoClip detection
function SecuritySystem:CheckNoClip(player, character, humanoid, rootPart)
    if humanoid:GetState() == Enum.HumanoidStateType.Running then
        local ray = Ray.new(rootPart.Position, Vector3.new(0, -5, 0))
        local part = workspace:FindPartOnRay(ray, character)
        
        if not part then
            self:Flag(player, "NoClip", "Character appears to be floating")
        end
    end
end

-- Remote event spam detection
function SecuritySystem:CheckRemoteSpam(player)
    local data = self.PlayerData[player]
    data.RemoteCount = data.RemoteCount + 1
    
    if data.RemoteCount > SECURITY_SETTINGS.RemoteRateLimit then
        self:Flag(player, "RemoteSpam", "Count: "..data.RemoteCount)
    end
    
    -- Reset counter after 1 second
    delay(1, function()
        data.RemoteCount = math.max(0, data.RemoteCount - SECURITY_SETTINGS.RemoteRateLimit)
    end)
end

-- Memory monitoring
function SecuritySystem:CheckMemory(player)
    local stats = player:GetJoinData().Stats
    if stats and stats.MemoryUsedMb > SECURITY_SETTINGS.MaxMemoryUsage then
        self:Flag(player, "MemoryHack", "Memory: "..stats.MemoryUsedMb.."MB")
    end
end

-- Flag a player for suspicious activity
function SecuritySystem:Flag(player, exploitType, details)
    local detection = {
        Player = player,
        Type = exploitType,
        Time = os.time(),
        Details = details
    }
    
    table.insert(self.Detections, detection)
    
    if SECURITY_SETTINGS.LogToConsole then
        warn(string.format("[SECURITY] %s detected using %s (%s)", player.Name, exploitType, details))
    end
    
    if SECURITY_SETTINGS.AutoKick then
        player:Kick("Anti-Exploit: "..exploitType)
    end
end

-- Clean up when player leaves
function SecuritySystem:Cleanup(player)
    local data = self.PlayerData[player]
    if data then
        for _, connection in pairs(data.Connections) do
            if type(connection) == "userdata" then
                connection:Disconnect()
            elseif type(connection) == "thread" then
                coroutine.close(connection)
            end
        end
        self.PlayerData[player] = nil
    end
end

-- Initialize security system
Players.PlayerAdded:Connect(function(player)
    SecuritySystem:TrackPlayer(player)
    
    -- Initial memory check
    SecuritySystem:CheckMemory(player)
    
    -- Periodic memory checks
    player:SetAttribute("Security_LastMemoryCheck", os.time())
    while player and player.Parent do
        if os.time() - player:GetAttribute("Security_LastMemoryCheck") > 60 then
            SecuritySystem:CheckMemory(player)
            player:SetAttribute("Security_LastMemoryCheck", os.time())
        end
        wait(10)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    SecuritySystem:Cleanup(player)
end)

-- Monitor existing players
for _, player in ipairs(Players:GetPlayers()) do
    SecuritySystem:TrackPlayer(player)
end

return SecuritySystem