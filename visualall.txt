-- Sistema de Espejo de Ejecuciones Locales
-- Este script hace que las ejecuciones locales sean visibles para otros jugadores
-- Simplemente coloca este script en StarterPlayerScripts

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Crear un RemoteEvent para comunicación
local mirrorEvent = Instance.new("RemoteEvent")
mirrorEvent.Name = "LocalExecutionMirror"
mirrorEvent.Parent = ReplicatedStorage

-- Configuración
local config = {
    enabled = true,           -- Activar/desactivar el sistema
    mirrorDecals = true,      -- Mostrar decals a otros jugadores
    mirrorParts = true,       -- Mostrar partes creadas a otros jugadores
    mirrorProperties = true,  -- Mostrar cambios de propiedades a otros jugadores
    maxItems = 100,           -- Máximo de elementos a rastrear
    cleanupTime = 30          -- Tiempo antes de limpiar elementos (segundos)
}

-- Preparar el sistema según el contexto
if RunService:IsServer() then
    -- LADO DEL SERVIDOR
    
    -- Almacenamiento para elementos sincronizados
    local syncedItems = {}
    local itemCount = 0
    
    -- Procesar solicitudes de sincronización de los clientes
    mirrorEvent.OnServerEvent:Connect(function(player, action, data)
        if not config.enabled then return end
        
        -- Verificar si hay demasiados elementos
        if itemCount > config.maxItems then
            -- Eliminar los elementos más antiguos
            for id, item in pairs(syncedItems) do
                if tick() - item.timestamp > config.cleanupTime then
                    syncedItems[id] = nil
                    itemCount = itemCount - 1
                end
            end
        end
        
        -- Generar ID único para el elemento
        local itemId = player.UserId .. "_" .. tick()
        
        -- Guardar en la lista de sincronizados
        syncedItems[itemId] = {
            timestamp = tick(),
            action = action,
            data = data,
            creator = player
        }
        itemCount = itemCount + 1
        
        -- Transmitir a todos los demás jugadores
        for _, otherPlayer in pairs(Players:GetPlayers()) do
            if otherPlayer ~= player then
                mirrorEvent:FireClient(otherPlayer, action, data, player.UserId)
            end
        end
        
        -- Eliminar después del tiempo especificado
        task.delay(config.cleanupTime, function()
            if syncedItems[itemId] then
                syncedItems[itemId] = nil
                itemCount = itemCount - 1
            end
        end)
    end)
    
    -- Cuando un jugador se une, enviarle todos los elementos activos
    Players.PlayerAdded:Connect(function(player)
        -- Esperar a que el jugador esté completamente cargado
        task.wait(3)
        
        for _, item in pairs(syncedItems) do
            if tick() - item.timestamp <= config.cleanupTime then
                mirrorEvent:FireClient(player, item.action, item.data, item.creator.UserId)
            end
        end
    end)
    
else
    -- LADO DEL CLIENTE
    local localPlayer = Players.LocalPlayer
    local mirrored = {}
    
    -- Función para convertir una instancia en una ruta
    local function getInstancePath(instance)
        if not instance then return nil end
        
        local path = {}
        local current = instance
        
        while current and current ~= game do
            table.insert(path, 1, current.Name)
            current = current.Parent
        end
        
        return table.concat(path, ".")
    end
    
    -- Función para obtener una instancia desde una ruta
    local function getInstanceFromPath(path)
        if not path then return nil end
        
        local parts = string.split(path, ".")
        local current = game
        
        for _, part in ipairs(parts) do
            current = current:FindFirstChild(part)
            if not current then return nil end
        end
        
        return current
    end
    
    -- Monitorear la creación de decals
    local originalDecalNew = Instance.new
    Instance.new = function(className, parent)
        local instance = originalDecalNew(className, parent)
        
        -- Si es un decal y está activado el espejo de decals
        if config.mirrorDecals and className == "Decal" and config.enabled then
            -- Esperar a que se establezcan sus propiedades
            task.delay(0.1, function()
                if instance and instance.Parent then
                    local parentPath = getInstancePath(instance.Parent)
                    
                    if parentPath then
                        -- Enviar al servidor para sincronizar
                        mirrorEvent:FireServer("decalCreated", {
                            parent = parentPath,
                            texture = instance.Texture,
                            face = instance.Face.Name,
                            transparency = instance.Transparency
                        })
                    end
                end
            end)
        end
        
        -- Si es una parte y está activado el espejo de partes
        if config.mirrorParts and (className == "Part" or className == "WedgePart" or className == "CornerWedgePart" or className == "TrussPart") and config.enabled then
            task.delay(0.1, function()
                if instance and instance.Parent then
                    local parentPath = getInstancePath(instance.Parent)
                    
                    if parentPath then
                        -- Enviar al servidor para sincronizar
                        mirrorEvent:FireServer("partCreated", {
                            parent = parentPath,
                            className = className,
                            size = {instance.Size.X, instance.Size.Y, instance.Size.Z},
                            position = {instance.Position.X, instance.Position.Y, instance.Position.Z},
                            color = {instance.Color.R, instance.Color.G, instance.Color.B},
                            transparency = instance.Transparency,
                            material = instance.Material.Name
                        })
                    end
                end
            end)
        end
        
        return instance
    end
    
    -- Recibir sincronizaciones del servidor
    mirrorEvent.OnClientEvent:Connect(function(action, data, creatorId)
        -- No procesar si está desactivado o si es nuestro propio evento
        if not config.enabled or creatorId == localPlayer.UserId then return end
        
        if action == "decalCreated" and config.mirrorDecals then
            local parent = getInstanceFromPath(data.parent)
            
            if parent then
                -- Crear el decal localmente
                local decal = originalDecalNew("Decal")
                decal.Texture = data.texture
                decal.Face = Enum.NormalId[data.face]
                decal.Transparency = data.transparency
                decal.Parent = parent
                
                -- Registrar para limpieza
                table.insert(mirrored, {
                    instance = decal,
                    timestamp = tick()
                })
                
                -- Eliminar después del tiempo especificado
                task.delay(config.cleanupTime, function()
                    if decal and decal.Parent then
                        decal:Destroy()
                    end
                end)
            end
        elseif action == "partCreated" and config.mirrorParts then
            local parent = getInstanceFromPath(data.parent)
            
            if parent then
                -- Crear la parte localmente
                local part = originalDecalNew(data.className)
                part.Size = Vector3.new(data.size[1], data.size[2], data.size[3])
                part.Position = Vector3.new(data.position[1], data.position[2], data.position[3])
                part.Color = Color3.new(data.color[1], data.color[2], data.color[3])
                part.Transparency = data.transparency
                part.Material = Enum.Material[data.material]
                part.Anchored = true
                part.CanCollide = false
                part.Parent = parent
                
                -- Registrar para limpieza
                table.insert(mirrored, {
                    instance = part,
                    timestamp = tick()
                })
                
                -- Eliminar después del tiempo especificado
                task.delay(config.cleanupTime, function()
                    if part and part.Parent then
                        part:Destroy()
                    end
                end)
            end
        end
    end)
    
    -- Limpiar elementos antiguos periódicamente
    task.spawn(function()
        while true do
            task.wait(10)
            
            local i = 1
            while i <= #mirrored do
                if tick() - mirrored[i].timestamp > config.cleanupTime then
                    if mirrored[i].instance and mirrored[i].instance.Parent then
                        mirrored[i].instance:Destroy()
                    end
                    table.remove(mirrored, i)
                else
                    i = i + 1
                end
            end
        end
    end)
    
    print("Sistema de Espejo de Ejecuciones Locales inicializado")
end